# -*- coding: utf-8 -*-
"""system 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OrqFmtbm83O17__utZ_aHy2ryigflvnT
"""

import math
import requests
import datetime

# =============================================
# 1. WEATHER DATA FROM API (Open-Meteo)
# =============================================
def get_location_data(location_name: str):
    """
    Fetches latitude, longitude, and elevation for a given location name
    using the Open-Meteo Geocoding API.

    Parameters:
    - location_name: The name of the location to search (e.g., "Paris", "Mount Everest")

    Returns:
    - A dictionary with location data if successful, None otherwise.
    """
    # Base URL for the Open-Meteo Geocoding API
    base_url = "https://geocoding-api.open-meteo.com/v1/search"

    # Parameters for the API request
    # 'count=1' tells the API to only return the single, most likely result
    params = {
        "name": location_name,
        "count": 1
    }

    try:
        # Make the GET request to the API
        response = requests.get(base_url, params=params)

        # Raise an HTTPError if the HTTP request returned an unsuccessful status code
        response.raise_for_status()

        # Parse the JSON response
        data = response.json()

        # Check if the 'results' key exists and has data
        if "results" in data and len(data["results"]) > 0:
            # Extract the first and most relevant result
            location_info = data["results"][0]

            # Prepare the data to be returned
            result = {
                "name": location_info.get("name"),
                "latitude": location_info.get("latitude"),
                "longitude": location_info.get("longitude"),
                "elevation": location_info.get("elevation"),
                "country": location_info.get("country"),
                "timezone": location_info.get("timezone")
            }
            return result
        else:
            print(f"Error: Location '{location_name}' not found.")
            return None

    except requests.exceptions.HTTPError as err_http:
        print(f"HTTP Error: {err_http}")
    except requests.exceptions.ConnectionError as err_conn:
        print(f"Connection Error: {err_conn}")
    except requests.exceptions.Timeout as err_timeout:
        print(f"Timeout Error: {err_timeout}")
    except requests.exceptions.RequestException as err:
        print(f"An unexpected error occurred: {err}")

    return None

def fetch_weather(lat: float, lon: float, z: float, date: str = None) -> dict:
    if date is None:
        date = datetime.date.today().isoformat()

    url = "https://api.open-meteo.com/v1/forecast"
    params = {
        "latitude": lat,
        "longitude": lon,
        "daily": "temperature_2m_max,temperature_2m_min,shortwave_radiation_sum,wind_speed_10m_max",
        "hourly": "relative_humidity_2m",
        "start_date": date,
        "end_date": date,
        "timezone": "auto"
    }
    resp = requests.get(url, params=params)
    data = resp.json()

    daily = data['daily']
    hourly_rh = data['hourly']['relative_humidity_2m']

    # Wind speed at 10m → convert to 2m
    u10 = daily['wind_speed_10m_max'][0]
    u2 = u10 * (4.87 / math.log(67.8 * 10 - 5.42))

    return {
        "T_max": daily['temperature_2m_max'][0],
        "T_min": daily['temperature_2m_min'][0],
        "RH_max": max(hourly_rh),
        "RH_min": min(hourly_rh),
        "Rs": daily['shortwave_radiation_sum'][0],  # MJ/m²/day
        "u2": u2
    }

# =============================================
# 2. ETc CALCULATION (FAO-56 Penman-Monteith)
# =============================================
def calculate_ETc(T_max, T_min, RH_max, RH_min, Rs, u2, z, latitude, J, Kc):
    T = (T_max + T_min) / 2

    def e_s(T): return 0.6108 * math.exp(17.27 * T / (T + 237.3))
    es = (e_s(T_max) + e_s(T_min)) / 2
    ea = (e_s(T_min) * (RH_max / 100) + e_s(T_max) * (RH_min / 100)) / 2
    Delta = 4098 * es / ((T + 237.3) ** 2)
    P = 101.3 * ((293 - 0.0065 * z) / 293) ** 5.26
    gamma = 0.000665 * P
    dr = 1 + 0.033 * math.cos(2 * math.pi * J / 365)
    delta_solar = 0.409 * math.sin(2 * math.pi * J / 365 - 1.39)
    phi = latitude * math.pi / 180
    omega_s = math.acos(-math.tan(phi) * math.tan(delta_solar))
    Ra = (24 * 60 / math.pi) * 0.082 * dr * (
        omega_s * math.sin(phi) * math.sin(delta_solar) +
        math.cos(phi) * math.cos(delta_solar) * math.sin(omega_s)
    )
    Rso = (0.75 + 2e-5 * z) * Ra
    Rns = (1 - 0.23) * Rs
    sigma = 4.903e-9
    Rnl = sigma * ((T_max + 273.16)**4 + (T_min + 273.16)**4) / 2 * \
          (0.34 - 0.14 * math.sqrt(ea)) * (1.35 * (Rs / Rso) - 0.35)
    Rn = Rns - Rnl
    G = 0  # Daily → negligible
    ET0 = (0.408 * Delta * (Rn - G) + gamma * (900 / (T + 273)) * u2 * (es - ea)) / \
          (Delta + gamma * (1 + 0.34 * u2))
    return Kc * ET0  # ETc in mm/day

# =============================================
# 3. SOIL WATER BALANCE & IRRIGATION NEED
# =============================================
def calculate_irrigation_need(
    soil_moisture_percent: float,
    field_capacity: float,
    wilting_point: float,
    root_depth_mm: float,
    ETc: float,
    MAD: float = 0.50  # 50% depletion allowed
) -> float:
    """
    Returns mm of water to apply today.
    Only irrigates if soil moisture < MAD threshold.
    """
    # Total Available Water (TAW) in root zone (mm)
    TAW = (field_capacity - wilting_point) * root_depth_mm

    # Readily Available Water (RAW) = MAD fraction of TAW
    RAW = MAD * TAW

    # Current soil water (mm)
    current_water = soil_moisture_percent * root_depth_mm

    # Target water level = WP + RAW
    target_water = wilting_point * root_depth_mm + RAW

    # Deficit = how much water is missing to reach target
    deficit = max(0, target_water - current_water)

    # Final irrigation = deficit (to refill to MAD threshold)
    # But do not exceed ETc (avoid over-irrigation in one day)
    irrigation_needed = min(deficit, ETc * 1.1)  # Allow slight excess for efficiency

    return round(irrigation_needed, 2)

# =============================================
# 4. MAIN FUNCTION: FULLY AUTOMATED
# =============================================
def get_daily_irrigation_recommendation(
    lat: float, lon: float, z: float, Kc: float,
    soil_moisture_percent: float,
    field_capacity: float = 35.0,      # % (e.g., loam)
    wilting_point: float = 15.0,       # %
    root_depth_mm: float = 400,        # mm (adjust per growth stage)
    MAD: float = 0.5,                  # 50%
    date: str = None
) -> dict:
    """
    One-call function: returns full water status + irrigation recommendation.
    """
    # 1. Get weather
    weather = fetch_weather(lat, lon, z, date)
    J = datetime.date.fromisoformat(date or datetime.date.today().isoformat()).timetuple().tm_yday

    # 2. Calculate ETc
    ETc = calculate_ETc(
        T_max=weather['T_max'],
        T_min=weather['T_min'],
        RH_max=weather['RH_max'],
        RH_min=weather['RH_min'],
        Rs=weather['Rs'],
        u2=weather['u2'],
        z=z,
        latitude=lat,
        J=J,
        Kc=Kc
    )

    # 3. Calculate irrigation
    irrigation_mm = calculate_irrigation_need(
        soil_moisture_percent=soil_moisture_percent,
        field_capacity=field_capacity,
        wilting_point=wilting_point,
        root_depth_mm=root_depth_mm,
        ETc=ETc,
        MAD=MAD
    )

    # 4. Return full report
    return {
        "date": date or datetime.date.today().isoformat(),
        "ETc_mm_per_day": round(ETc, 2),
        "soil_moisture_percent": soil_moisture_percent,
        "irrigation_needed_mm": irrigation_mm,
        "status": "Irrigate now" if irrigation_mm > 0 else "No irrigation needed",
        "recommendation": f"Apply {irrigation_mm} mm of water today." if irrigation_mm > 0 else "Soil is sufficiently moist."
    }


# =============================================
# EXAMPLE USAGE
# =============================================



# --- Example Usage ---

# 1. Search for a city
location1 = "Zaghouan"
data1 =get_location_data(location1)
# if data1:
#     print(f"\n--- Data for {location1} ---")
#     print(f"  Name: {data1['name']}, {data1['country']}")
#     print(f"  Latitude: {data1['latitude']:.4f}°")
#     print(f"  Longitude: {data1['longitude']:.4f}°")
#     print(f"  Elevation: {data1['elevation']} m")



if __name__ == "__main__":
    result = get_daily_irrigation_recommendation(
        lat=data1['latitude'],
        lon=data1['longitude'],      #Location data for Zaghouan
        z=data1['elevation'],

        soil_moisture_percent=18.0,          # From soil sensor

        MAD=0.5,
        field_capacity=32.0,                #= General Values for most fields, need a specific lab to modify specifically
        wilting_point=15.0,

        Kc=1.15,       # Possible CV solution
        root_depth_mm=500,


        date=None #Pregiven in the function
    )

    print("\nDAILY IRRIGATION REPORT")
    print("-" * 40)
    for k, v in result.items():
        print(f"{k.replace('_', ' ').title():25}: {v}")

