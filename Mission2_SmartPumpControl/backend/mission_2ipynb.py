# -*- coding: utf-8 -*-
"""mission .2ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E4OrOT6IBB3aXjPO2LFvjQVkqZHlUS8R

# ESP32 Firmware (Arduino IDE Code)
"""

#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// === CONFIG ===
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";
const char* backend_url = "http://YOUR_BACKEND_IP:5000/irrigate/plant_x";  // e.g., 192.168.1.100:5000

// Pins & Constants
const int RELAY_PIN = 2;  // GPIO for relay
const int FLOW_PIN = 4;   // Optional flow sensor
const float FLOW_RATE = 300.0;  // ml/min (calibrate your pump)
const float PULSE_PER_ML = 4.5; // For YF-S201; calibrate

// Globals
volatile float water_delivered = 0.0;
unsigned long last_poll = 0;
const unsigned long POLL_INTERVAL = 300000;  // 5 min

void IRAM_ATTR flow_pulse() {
  water_delivered += (1.0 / PULSE_PER_ML);  // Increment per pulse
}

void setup() {
  Serial.begin(115200);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, LOW);  // Pump off
  attachInterrupt(digitalPinToInterrupt(FLOW_PIN), flow_pulse, FALLING);  // If flow sensor

  // WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("WiFi connected!");
}

void loop() {
  if (millis() - last_poll > POLL_INTERVAL) {
    fetch_and_water();
    last_poll = millis();
  }
  delay(1000);  // Idle
}

void fetch_and_water() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(backend_url);
    int httpCode = http.GET();

    if (httpCode == 200) {
      String payload = http.getString();
      DynamicJsonDocument doc(1024);
      deserializeJson(doc, payload);

      bool on = doc["on"];
      float qte_needed = doc["qte_water_needed"];  // ml

      Serial.printf("Backend: on=%s, qte=%.1f ml\n", on ? "true" : "false", qte_needed);

      if (on) {
        water_pump(qte_needed);
      } else {
        stop_pump();
      }
    } else {
      Serial.printf("HTTP Error: %d\n", httpCode);
    }
    http.end();
  }
}

void water_pump(float target_ml) {
  water_delivered = 0.0;  // Reset
  digitalWrite(RELAY_PIN, HIGH);  // Turn on pump

  unsigned long start_time = millis();
  float runtime_sec = (target_ml / FLOW_RATE) * 60.0;  // e.g., 520 ml / 300 ml/min = 104 sec

  while (water_delivered < target_ml && (millis() - start_time) < (runtime_sec * 1000 + 5000)) {  // +5s buffer
    // Monitor flow; break if done
    if (water_delivered >= target_ml) break;
    delay(100);
  }

  stop_pump();
  Serial.printf("Watered %.1f ml (actual: %.1f ml)\n", target_ml, water_delivered);

  // Optional: POST feedback to backend
  send_feedback(target_ml, water_delivered);
}

void stop_pump() {
  digitalWrite(RELAY_PIN, LOW);
}

void send_feedback(float requested, float actual) {
  // Similar HTTP POST to /feedback endpoint
  // e.g., {"plant": "X", "requested": 5.2, "actual": 5.1}
  Serial.println("Feedback sent to backend");
}